import { QsoEntry } from '../types/qso';

interface AdifRecord {
  [key: string]: string;
}

export function parseAdif(content: string): AdifRecord[] {
  const records: AdifRecord[] = [];
  const headerEnd = content.toUpperCase().indexOf('<EOH>');
  
  if (headerEnd === -1) return records;
  
  const body = content.substring(headerEnd + 5);
  const regex = /<([^:>]+)(?::(\d+)(?::([^>]+))?)?>(.*?)(?=<|$)/gi;
  let currentRecord: AdifRecord = {};
  let match;

  while ((match = regex.exec(body)) !== null) {
    const [_, name, length, type, value] = match;
    const fieldName = name.toLowerCase();
    
    if (fieldName === 'eor') {
      if (Object.keys(currentRecord).length > 0) {
        records.push(currentRecord);
        currentRecord = {};
      }
    } else {
      currentRecord[fieldName] = value.trim();
    }
  }

  return records;
}

export function formatAdif(qsos: QsoEntry[]): string {
  const header = `Generated by HamLogger\n<adif_ver:5>3.1.0\n<programid:9>HamLogger\n<EOH>\n\n`;
  
  return qsos.reduce((adif, qso) => {
    const fields = [
      { name: 'CALL', value: qso.callsign || '' },
      { name: 'QSO_DATE', value: new Date(qso.datetime).toISOString().split('T')[0].replace(/-/g, '') },
      { name: 'TIME_ON', value: new Date(qso.datetime).toISOString().split('T')[1].substring(0,6).replace(/:/g, '') },
      { name: 'BAND', value: qso.band || '' },
      { name: 'MODE', value: qso.mode || '' },
      { name: 'FREQ', value: (qso.freqRx || 0).toString() },
      { name: 'RST_RCVD', value: qso.rstr || '' },
      { name: 'RST_SENT', value: qso.rstt || '' },
      { name: 'COMMENT', value: qso.remark || '' },
      { name: 'NOTES', value: qso.notes || '' },
      { name: 'APP_QRZLOG_LOGID', value: qso.qrzLogId || '' }
    ];

    const record = fields
      .map(f => {
        const value = f.value || '';
        return `<${f.name}:${value.length}>${value}`;
      })
      .join('');
      
    return adif + record + '<EOR>\n';
  }, header);
}
